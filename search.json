[{"title":"解决 jpa 的 save 过程用 null 值覆盖数据库有效值的问题","url":"/2019/07/19/解决-jpa-的-save-过程用-null-值覆盖数据库有效值的问题/","content":"\n最近在项目中使用 jpa 操作数据库的时候，遇到了一个问题。\n\n我所使用的数据库是 postgreSQL，通过定义实体类添加`@Table`注解指定表，定义接口继承`CrudRepository`类，将实体类作为参数传入，即可调用默认的 save 方法，jpa 会根据主键将实体进行插入或更新操作。\n\n但是，如果用于更新的实体中含有未赋值的属性，即值为 null 的情况时，数据库中对应字段的值会被 null 覆盖。\n\n我先是在 Google 查询了解决方案，有网友提出可以在实体类加上`@DynamicUpdate`和`@DynamicInsert`两个注解，序列化时即可忽略为 null 的值。我尝试了这种方法，启动单元测试进行了一次更新操作，却发现数据库的数据依然被 null 覆盖。\n\n为了寻找原因，我查看了这两个注解的源码，它们是在 hebernate-core 里定义的。使用 idea 的全局搜索找到了注解的实现代码,还没来得及看具体实现，却发现它被加上了`@Deprecated`注解。虽然理论上对使用是无影响的，但既然作者不推荐了，还是放弃使用吧。\n\n实在不想在苦苦寻找方法了，决定自己造个轮子，实现 update 的功能。逻辑非常简单，每次 save 之前先从数据库查找出对应数据存入实体A，将含有更新数据的实体B中的非空属性赋值给实体A，最后用实体 A 存回数据库。具体代码如下：\n\n```\n\t/**\n     * 防止 jpa 将为 null 的属性更新（因为注解DynamicUpdate无效）\n     *\n     * @param entity 包含需要更新字段的实体\n     * @param oldEntity 从数据库获取的旧实体\n     * @return 最终往数据库插入的实体\n     */\n     \n    public static <T> T updateEntity(T entity,T oldEntity){\n        Class clazz = entity.getClass();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields){\n            try {\n                PropertyDescriptor pd = new PropertyDescriptor(field.getName(), clazz);\n                Method readMethod = pd.getReadMethod();\n                Method writeMethod= pd.getWriteMethod();\n                if (readMethod.invoke(entity)!=null){   //不为null 的覆盖\n                    writeMethod.invoke(oldEntity,readMethod.invoke(entity));\n                }\n            }catch (Exception e){\n                log.error(e.getMessage());\n            }\n        }\n        return oldEntity;\n    }\n```\n\n利用反射+泛型写了个通用方法，将新旧实体作为参数传入，反射取出新实体中非 null 的值赋给旧实体，最后将旧实体返回。将方法封装成工具类方便调用。\n\n在代码中，每次更新数据库前调用一下工具，用返回的实体作为 save 对象，经测试，成功解决 null 覆盖问题。","tags":["Java","jpa","postgreSQL"]},{"title":"一篇测试文章","url":"/2019/07/19/测试文章1/","content":"\n测试一下 gui，能不能用\n感觉还行","tags":["测试","标签"]},{"title":"myTest","url":"/2019/07/19/myTest/"}]